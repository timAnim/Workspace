{
  "version": 3,
  "sources": ["../../../app/components/ThemeProvider.tsx"],
  "sourcesContent": ["import { createContext, useContext, useEffect, useRef, useState } from \"react\";\nimport type { Dispatch, ReactNode, SetStateAction } from \"react\";\nimport { useFetcher } from \"remix\";\n\nexport type Theme = \"dark\" | \"light\";\n\ntype ThemeContextType = [\n  Theme | undefined,\n  Dispatch<SetStateAction<Theme | undefined>>\n];\n\nconst ThemeContext = createContext<ThemeContextType | undefined>(undefined);\n\nconst prefersLightMQ = \"(prefers-color-scheme: light)\";\nconst getPreferredTheme = () =>\n  window.matchMedia(prefersLightMQ).matches ? \"light\" : \"dark\";\n\nexport function ThemeProvider({\n  children,\n  specifiedTheme,\n  themeOverride,\n}: {\n  children: ReactNode;\n  specifiedTheme?: Theme;\n  themeOverride?: Theme;\n}) {\n  const [theme, setTheme] = useState<Theme | undefined>(() => {\n    if (specifiedTheme) {\n      if (specifiedTheme === \"light\" || specifiedTheme === \"dark\") {\n        return specifiedTheme;\n      } else {\n        return;\n      }\n    }\n\n    // there's no way for us to know what the theme should be in this context\n    // the client will have to figure it out before hydration.\n    if (typeof window !== \"object\") {\n      return;\n    }\n\n    return getPreferredTheme();\n  });\n\n  const mountRun = useRef(false);\n  const persistTheme = useFetcher();\n\n  useEffect(() => {\n    if (!mountRun.current) {\n      mountRun.current = true;\n      return;\n    }\n\n    if (!theme) {\n      return;\n    }\n\n    persistTheme.submit(\n      { theme },\n      { action: \"actions/setTheme\", method: \"post\" }\n    );\n  }, [theme]);\n\n  return (\n    <ThemeContext.Provider value={[themeOverride ?? theme, setTheme]}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\nexport function useTheme(): ThemeContextType {\n  const context = useContext(ThemeContext);\n  if (context === undefined) {\n    throw new Error(\"useTheme must be used within a ThemeProvider\");\n  }\n  return context;\n}\n\nconst clientThemeCode = `\n;(() => {\n  const theme = window.matchMedia(${JSON.stringify(prefersLightMQ)}).matches\n    ? 'light'\n    : 'dark';\n  const cl = document.documentElement.classList;\n  const themeAlreadyApplied = cl.contains('light') || cl.contains('dark');\n  if (themeAlreadyApplied) {\n    // this script shouldn't exist if the theme is already applied!\n    console.warn(\n      \"Hi there, could you let us know you're seeing this message? Thanks!\",\n    );\n  } else {\n    cl.add(theme);\n  }\n})();\n`;\n\nexport function NonFlashOfWrongThemeEls({ ssrTheme }: { ssrTheme: boolean }) {\n  return (\n    <>\n      {ssrTheme ? null : (\n        <script dangerouslySetInnerHTML={{ __html: clientThemeCode }} />\n      )}\n    </>\n  );\n}\n\nexport function isTheme(value: unknown): value is Theme {\n  return typeof value === \"string\" && [\"light\", \"dark\"].includes(value);\n}\n"],
  "mappings": ";;;;;;;;;;;AAAA;AAAA,mBAAuE;AAWvE,IAAM,eAAe,gCAA4C;AAEjE,IAAM,iBAAiB;AACvB,IAAM,oBAAoB,MACxB,OAAO,WAAW,gBAAgB,UAAU,UAAU;AAEjD,uBAAuB;AAAA,EAC5B;AAAA,EACA;AAAA,EACA;AAAA,GAKC;AACD,QAAM,CAAC,OAAO,YAAY,2BAA4B,MAAM;AAC1D,QAAI,gBAAgB;AAClB,UAAI,mBAAmB,WAAW,mBAAmB,QAAQ;AAC3D,eAAO;AAAA,aACF;AACL;AAAA;AAAA;AAMJ,QAAI,OAAO,WAAW,UAAU;AAC9B;AAAA;AAGF,WAAO;AAAA;AAGT,QAAM,WAAW,yBAAO;AACxB,QAAM,eAAe;AAErB,8BAAU,MAAM;AACd,QAAI,CAAC,SAAS,SAAS;AACrB,eAAS,UAAU;AACnB;AAAA;AAGF,QAAI,CAAC,OAAO;AACV;AAAA;AAGF,iBAAa,OACX,EAAE,SACF,EAAE,QAAQ,oBAAoB,QAAQ;AAAA,KAEvC,CAAC;AAEJ,SACE,oCAAC,aAAa,UAAd;AAAA,IAAuB,OAAO,CAAC,wCAAiB,OAAO;AAAA,KACpD;AAAA;AAKA,oBAAsC;AAC3C,QAAM,UAAU,6BAAW;AAC3B,MAAI,YAAY,QAAW;AACzB,UAAM,IAAI,MAAM;AAAA;AAElB,SAAO;AAAA;AAGT,IAAM,kBAAkB;AAAA;AAAA,oCAEY,KAAK,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgB5C,iCAAiC,EAAE,YAAmC;AAC3E,SACE,0DACG,WAAW,OACV,oCAAC,UAAD;AAAA,IAAQ,yBAAyB,EAAE,QAAQ;AAAA;AAAA;AAM5C,iBAAiB,OAAgC;AACtD,SAAO,OAAO,UAAU,YAAY,CAAC,SAAS,QAAQ,SAAS;AAAA;",
  "names": []
}
