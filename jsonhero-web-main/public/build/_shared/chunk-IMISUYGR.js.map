{
  "version": 3,
  "sources": ["../../../app/hooks/useJsonTree.tsx", "../../../app/hooks/useVirtualTree.ts", "../../../node_modules/react-virtual/node_modules/@reach/observe-rect/dist/observe-rect.esm.js", "../../../node_modules/react-virtual/src/useIsomorphicLayoutEffect.js", "../../../node_modules/react-virtual/src/useRect.js", "../../../node_modules/react-virtual/src/index.js"],
  "sourcesContent": ["import { useJson } from \"./useJson\";\nimport { inferType, JSONValueType } from \"@jsonhero/json-infer-types\";\nimport { JSONHeroPath } from \"@jsonhero/path\";\nimport { IconComponent } from \"~/useColumnView\";\nimport { formatValue } from \"~/utilities/formatter\";\nimport { iconForType } from \"~/utilities/icons\";\nimport {\n  createContext,\n  ReactNode,\n  useCallback,\n  useContext,\n  useMemo,\n  useRef,\n} from \"react\";\nimport { useVirtualTree, UseVirtualTreeInstance } from \"./useVirtualTree\";\nimport invariant from \"tiny-invariant\";\nimport { useJsonDoc } from \"./useJsonDoc\";\n\nconst initialRect = { width: 800, height: 600 };\n\nexport type JsonTreeOptions = {\n  overscan?: number;\n};\n\nexport type UseJsonTreeInstance = {\n  tree: UseVirtualTreeInstance<JsonTreeViewNode>;\n  parentRef: React.RefObject<HTMLDivElement>;\n};\n\nexport type JsonTreeViewType = UseJsonTreeInstance;\n\nconst JsonTreeViewContext = createContext<JsonTreeViewType>(\n  {} as JsonTreeViewType\n);\n\nexport function JsonTreeViewProvider({\n  children,\n  ...options\n}: { children: ReactNode } & JsonTreeOptions) {\n  const instance = useJsonTree(options);\n\n  return (\n    <JsonTreeViewContext.Provider value={instance}>\n      {children}\n    </JsonTreeViewContext.Provider>\n  );\n}\n\nexport function useJsonTree(options: JsonTreeOptions): UseJsonTreeInstance {\n  const parentRef = useRef<HTMLDivElement>(null);\n\n  const { doc } = useJsonDoc();\n  const [json] = useJson();\n  const jsonNodes = useMemo(() => {\n    return generateTreeViewNodes(json);\n  }, [json]);\n\n  const tree = useVirtualTree({\n    id: doc.id,\n    nodes: jsonNodes,\n    parentRef,\n    estimateSize: useCallback((index) => 32, []),\n    initialRect,\n    overscan: options.overscan,\n    persistState: true,\n  });\n\n  return { tree, parentRef };\n}\n\nexport function useJsonTreeViewContext(): JsonTreeViewType {\n  const context = useContext(JsonTreeViewContext);\n\n  invariant(\n    context,\n    \"useJsonTreeViewContext must be used within a JsonTreeViewContext.Provider\"\n  );\n\n  return context;\n}\n\nexport type JsonTreeViewNode = {\n  id: string;\n  name: string;\n  title: string;\n  subtitle?: string;\n  longTitle?: string;\n  icon?: IconComponent;\n  children?: Array<JsonTreeViewNode>;\n};\n\nexport function generateTreeViewNodes(json: unknown): Array<JsonTreeViewNode> {\n  const info = inferType(json);\n  const path = new JSONHeroPath(\"$\");\n\n  return generateChildren(info, path) ?? [];\n}\n\nfunction generateChildren(\n  info: JSONValueType,\n  path: JSONHeroPath\n): Array<JsonTreeViewNode> | undefined {\n  if (info.name === \"array\") {\n    return info.value.map((item, index) => {\n      const itemInfo = inferType(item);\n      const itemPath = path.child(index.toString());\n\n      return {\n        id: itemPath.toString(),\n        name: index.toString(),\n        title: index.toString(),\n        longTitle: `Index ${index.toString()}`,\n        subtitle: formatValue(itemInfo),\n        icon: iconForType(itemInfo),\n        children: generateChildren(itemInfo, itemPath),\n      };\n    });\n  }\n\n  if (info.name === \"object\") {\n    return Object.entries(info.value).map(([key, value]) => {\n      const cleanKey = key.replace(/\\./g, \"\\\\.\");\n      const itemInfo = inferType(value);\n      const itemPath = path.child(cleanKey);\n      return {\n        id: itemPath.toString(),\n        name: key,\n        title: key,\n        subtitle: formatValue(itemInfo),\n        icon: iconForType(itemInfo),\n        children: generateChildren(itemInfo, itemPath),\n      };\n    });\n  }\n}\n", "import pick from \"lodash-es/pick\";\nimport React, {\n  useReducer,\n  Reducer,\n  useCallback,\n  Dispatch,\n  useEffect,\n  useRef,\n} from \"react\";\nimport { useVirtual, VirtualItem } from \"react-virtual\";\n\ntype UseVirtualOptions<R> = Parameters<typeof useVirtual>[0];\n\nexport type UseVirtualTreeOptions<\n  T extends { id: string; children?: T[] },\n  R\n> = {\n  id: string;\n  persistState?: boolean;\n  nodes: T[];\n} & Omit<UseVirtualOptions<R>, \"size\">;\n\nexport type VirtualNode<T> = {\n  node: T;\n  size: number; // This is the same as virtualItem.size\n  start: number; // This is the same as virtualItem.start\n  virtualItem: VirtualItem;\n  depth: number;\n  getItemProps: () => React.HTMLAttributes<HTMLElement>;\n  isCollapsed?: boolean;\n};\n\nexport type UseVirtualTreeInstance<T> = {\n  nodes: VirtualNode<T>[];\n  focusedNodeId: string | null;\n  totalSize: number;\n  toggleNode: (id: string, source?: KeyboardEvent | MouseEvent) => void;\n  focusNode: (id: string) => void;\n  focusFirst: () => void;\n  blur: () => void;\n  scrollToNode: (id: string) => void;\n  getTreeProps: () => React.HTMLAttributes<HTMLElement>;\n};\n\ntype TreeNodeItem<T extends { id: string; children?: T[] }> = {\n  id: string;\n  depth: number;\n  node: T;\n  pos: number;\n  size: number;\n  isCollapsed: boolean;\n};\n\ntype TreeState<T extends { id: string; children?: T[] }> = {\n  nodes: T[];\n  items: TreeNodeItem<T>[];\n  collapsedState: Record<string, boolean>;\n  focusedNodeId: string | null;\n};\n\ntype ToggleNodeAction = {\n  type: \"TOGGLE_NODE\";\n  id: string;\n  source?: KeyboardEvent | MouseEvent;\n};\n\ntype FocusNodeAction = {\n  type: \"FOCUS_NODE\";\n  id: string;\n};\n\ntype MoveNodeAction = {\n  type: \"MOVE_DOWN\" | \"MOVE_UP\" | \"MOVE_TO_TOP\" | \"MOVE_TO_BOTTOM\";\n  source: KeyboardEvent | MouseEvent;\n};\n\ntype MoveRightAction = {\n  type: \"MOVE_RIGHT\";\n  source: KeyboardEvent | MouseEvent;\n};\n\ntype MoveLeftAction = {\n  type: \"MOVE_LEFT\";\n  source: KeyboardEvent | MouseEvent;\n};\n\ntype FocusFirstAction = {\n  type: \"FOCUS_FIRST\";\n};\n\ntype RestoreStateAction = {\n  type: \"RESTORE_STATE\";\n  restoredState: { collapsedState: Record<string, boolean> };\n};\n\ntype ExpandAllOnPathAction = {\n  type: \"EXPAND_ALL_ON_PATH\";\n  path: string[];\n};\n\ntype BlurAction = {\n  type: \"BLUR\";\n};\n\ntype CollapseAllNodesAction = {\n  type: \"COLLAPSE_ALL_NODES\"\n};\n\ntype TreeAction =\n  | ToggleNodeAction\n  | MoveNodeAction\n  | FocusNodeAction\n  | FocusFirstAction\n  | MoveRightAction\n  | MoveLeftAction\n  | RestoreStateAction\n  | ExpandAllOnPathAction\n  | BlurAction\n  | CollapseAllNodesAction;\n\nfunction expandNode<T extends { id: string; children?: T[] }>(\n  state: TreeState<T>,\n  id: string\n): TreeState<T> {\n  const collapsedState = {\n    ...state.collapsedState,\n    [id]: false,\n  };\n\n  return {\n    ...state,\n    collapsedState,\n    items: createNodeItems(state.nodes, 0, collapsedState),\n    focusedNodeId: id,\n  };\n}\n\nfunction collapseNode<T extends { id: string; children?: T[] }>(\n  state: TreeState<T>,\n  id: string\n): TreeState<T> {\n  const collapsedState = {\n    ...state.collapsedState,\n    [id]: true,\n  };\n\n  return {\n    ...state,\n    collapsedState,\n    items: createNodeItems(state.nodes, 0, collapsedState),\n    focusedNodeId: id,\n  };\n}\nfunction toggleAllChildren<T extends { id: string; children?: T[] }>(\n  state: TreeState<T>,\n  id: string\n): TreeState<T> {\n  const item = state.items.find(({ id: nodeId }) => nodeId === id);\n\n  if (!item) {\n    return state;\n  }\n\n  if (!item.node.children || item.node.children.length === 0) {\n    return state;\n  }\n\n  const allCollapsed = item.node.children.every(\n    (child) => state.collapsedState[child.id]\n  );\n\n  if (allCollapsed) {\n    const collapsedState = item.node.children.reduce(\n      (acc, child) => ({\n        ...acc,\n        [child.id]: false,\n      }),\n      state.collapsedState\n    );\n\n    return {\n      ...state,\n      collapsedState,\n      items: createNodeItems(state.nodes, 0, collapsedState),\n      focusedNodeId: id,\n    };\n  }\n\n  const collapsedState = item.node.children.reduce(\n    (acc, child) => ({\n      ...acc,\n      [child.id]: true,\n    }),\n    state.collapsedState\n  );\n\n  return {\n    ...state,\n    collapsedState,\n    items: createNodeItems(state.nodes, 0, collapsedState),\n    focusedNodeId: id,\n  };\n}\n\nexport function useVirtualTree<T extends { id: string; children?: T[] }, R>(\n  options: UseVirtualTreeOptions<T, R>\n): UseVirtualTreeInstance<T> {\n  const reducer = useCallback<Reducer<TreeState<T>, TreeAction>>(\n    (state, action) => {\n      switch (action.type) {\n        case \"BLUR\": {\n          return {\n            ...state,\n            focusedNodeId: null,\n          };\n        }\n        case \"TOGGLE_NODE\": {\n          const isCollapsed = state.collapsedState[action.id];\n\n          if (isCollapsed) {\n            return expandNode<T>(state, action.id);\n          } else {\n            if (\n              action.source &&\n              (action.source.shiftKey || action.source.altKey)\n            ) {\n              return toggleAllChildren<T>(state, action.id);\n            } else {\n              return collapseNode<T>(state, action.id);\n            }\n          }\n        }\n        case \"COLLAPSE_ALL_NODES\": {\n          // Reduce from the right, so that the\n          // focusedNodeId is set to the top-level node.\n          return state.items.reduceRight(\n            (nextState, item) => collapseNode<T>(nextState, item.id),\n            state\n          );\n        }\n        case \"FOCUS_NODE\": {\n          const itemIndex = state.items.findIndex(({ id }) => id === action.id);\n\n          if (itemIndex === -1) {\n            const node = findNodeInTreeById(state.nodes, action.id);\n\n            if (!node) {\n              return state;\n            }\n\n            const path = calculatePathToNode(state.nodes, node) ?? [];\n\n            const collapsedState = path.reduce(\n              (acc, id) => ({\n                ...acc,\n                [id]: false,\n              }),\n              state.collapsedState\n            );\n\n            return {\n              ...state,\n              collapsedState,\n              items: createNodeItems(state.nodes, 0, collapsedState),\n              focusedNodeId: action.id,\n            };\n          }\n\n          return {\n            ...state,\n            focusedNodeId: action.id,\n          };\n        }\n        case \"FOCUS_FIRST\":\n        case \"MOVE_TO_TOP\": {\n          const nextItem = state.items[0];\n\n          if (!nextItem) {\n            return state;\n          }\n\n          return {\n            ...state,\n            focusedNodeId: nextItem.id,\n          };\n        }\n        case \"MOVE_TO_BOTTOM\": {\n          const nextItem = state.items[state.items.length - 1];\n\n          if (!nextItem) {\n            return state;\n          }\n\n          return {\n            ...state,\n            focusedNodeId: nextItem.id,\n          };\n        }\n        case \"MOVE_DOWN\": {\n          if (!state.focusedNodeId) {\n            const nextItem = state.items[0];\n\n            if (!nextItem) {\n              return state;\n            }\n\n            return {\n              ...state,\n              focusedNodeId: nextItem.id,\n            };\n          }\n\n          const focusedNodeIdIndex = state.items.findIndex(\n            (item) => item.id === state.focusedNodeId\n          );\n\n          if (focusedNodeIdIndex === -1) {\n            return state;\n          }\n\n          if (state.items.length <= focusedNodeIdIndex + 1) {\n            return state;\n          }\n\n          const nextItem = state.items[focusedNodeIdIndex + 1];\n\n          return {\n            ...state,\n            focusedNodeId: nextItem.id,\n          };\n        }\n        case \"MOVE_UP\": {\n          const focusedNodeIdIndex = state.items.findIndex(\n            (item) => item.id === state.focusedNodeId\n          );\n\n          if (focusedNodeIdIndex === -1) {\n            return state;\n          }\n\n          if (focusedNodeIdIndex === 0) {\n            return state;\n          }\n\n          const nextItem = state.items[focusedNodeIdIndex - 1];\n\n          return {\n            ...state,\n            focusedNodeId: nextItem.id,\n          };\n        }\n        case \"MOVE_RIGHT\": {\n          if (!state.focusedNodeId) {\n            return state;\n          }\n\n          const isCollapsed = state.collapsedState[state.focusedNodeId];\n\n          if (isCollapsed) {\n            return expandNode<T>(state, state.focusedNodeId);\n          }\n\n          if (\n            action.source &&\n            (action.source.shiftKey || action.source.altKey)\n          ) {\n            return toggleAllChildren<T>(state, state.focusedNodeId);\n          }\n\n          const nodeIndex = state.items.findIndex(\n            (item) => item.id === state.focusedNodeId\n          );\n\n          if (nodeIndex === -1) {\n            return state;\n          }\n\n          if (state.items.length <= nodeIndex + 1) {\n            return state;\n          }\n\n          const nextItem = state.items[nodeIndex + 1];\n\n          return {\n            ...state,\n            focusedNodeId: nextItem.id,\n          };\n        }\n        case \"MOVE_LEFT\": {\n          if (!state.focusedNodeId) {\n            return state;\n          }\n\n          const item = state.items.find(\n            (item) => item.id === state.focusedNodeId\n          );\n\n          if (!item) {\n            return state;\n          }\n\n          const hasChildren =\n            item.node.children && item.node.children.length > 0;\n          const isCollapsed = state.collapsedState[state.focusedNodeId];\n\n          if (hasChildren && !isCollapsed) {\n            if (\n              action.source &&\n              (action.source.shiftKey || action.source.altKey)\n            ) {\n              return toggleAllChildren<T>(state, state.focusedNodeId);\n            } else {\n              return collapseNode<T>(state, state.focusedNodeId);\n            }\n          }\n\n          if (!hasChildren || isCollapsed) {\n            // Try to go to the parent node\n            const parentNodeIndex = state.items.findIndex(\n              (item) =>\n                item.node.children &&\n                item.node.children\n                  .map((child) => child.id)\n                  .includes(state.focusedNodeId!)\n            );\n\n            if (parentNodeIndex === -1) {\n              return state;\n            }\n\n            const nextItem = state.items[parentNodeIndex];\n\n            return {\n              ...state,\n              focusedNodeId: nextItem.id,\n            };\n          }\n\n          return state;\n        }\n        case \"RESTORE_STATE\": {\n          const nextState = {\n            ...state,\n            ...action.restoredState,\n          };\n\n          return {\n            ...nextState,\n            items: createNodeItems(\n              nextState.nodes,\n              0,\n              nextState.collapsedState\n            ),\n          };\n        }\n        default:\n          return state;\n      }\n    },\n    []\n  );\n\n  const initializer = useCallback(\n    ({ nodes }: { nodes: T[] }) => {\n      return {\n        nodes,\n        items: createNodeItems(nodes),\n        collapsedState: {},\n        focusedNodeId: null,\n      };\n    },\n    [options.persistState, options.id]\n  );\n\n  const [state, dispatch] = useReducer<\n    Reducer<TreeState<T>, TreeAction>,\n    { nodes: T[] }\n  >(\n    reducer,\n    {\n      nodes: options.nodes,\n    },\n    initializer\n  );\n\n  const isStateRestored = useRef<boolean>(false);\n\n  // This is setting the state\n  useEffect(() => {\n    if (!isStateRestored.current) {\n      return;\n    }\n\n    if (options.persistState) {\n      localStorage.setItem(\n        `${options.id}-virtual-tree-state`,\n        JSON.stringify(pick(state, \"collapsedState\"))\n      );\n    }\n  }, [\n    state.collapsedState,\n    options.id,\n    options.persistState,\n    isStateRestored.current,\n  ]);\n\n  // This is restoring the state\n  useEffect(() => {\n    if (!options.persistState) {\n      return;\n    }\n\n    if (isStateRestored.current) {\n      return;\n    }\n\n    isStateRestored.current = true;\n\n    const savedState = localStorage.getItem(`${options.id}-virtual-tree-state`);\n\n    if (savedState) {\n      const restoredState = JSON.parse(savedState) as {\n        collapsedState: Record<string, boolean>;\n      };\n\n      dispatch({\n        type: \"RESTORE_STATE\",\n        restoredState,\n      });\n    }\n  }, [options.persistState, options.id, dispatch, isStateRestored.current]);\n\n  const rowVirtualizer = useVirtual({\n    size: state.items.length,\n    parentRef: options.parentRef,\n    estimateSize: options.estimateSize,\n    overscan: options.overscan,\n    initialRect: options.initialRect,\n    useObserver: options.useObserver,\n  });\n\n  const allVirtualNodes = rowVirtualizer.virtualItems.map((virtualItem) => {\n    const treeItem = state.items[virtualItem.index];\n\n    return {\n      node: treeItem.node,\n      depth: treeItem.depth,\n      size: virtualItem.size,\n      start: virtualItem.start,\n      virtualItem,\n      getItemProps: createItemProps(treeItem, virtualItem, state, dispatch),\n      isCollapsed: treeItem.isCollapsed,\n    };\n  });\n\n  const toggleNode = useCallback(\n    (id: string, source?: KeyboardEvent | MouseEvent) => {\n      dispatch({ type: \"TOGGLE_NODE\", id, source });\n    },\n    [dispatch]\n  );\n\n  const focusNode = useCallback(\n    (id: string) => {\n      dispatch({ type: \"FOCUS_NODE\", id });\n    },\n    [dispatch]\n  );\n\n  const focusFirst = useCallback(\n    () => dispatch({ type: \"FOCUS_FIRST\" }),\n    [dispatch]\n  );\n\n  const blur = useCallback(() => dispatch({ type: \"BLUR\" }), [dispatch]);\n\n  // TODO: have this work with collapsed nodes\n  const scrollToNode = useCallback(\n    (id: string) => {\n      const itemIndex = state.items.findIndex((item) => item.id === id);\n\n      if (itemIndex !== -1) {\n        rowVirtualizer.scrollToIndex(itemIndex, { align: \"auto\" });\n      }\n    },\n    [state.items, rowVirtualizer.scrollToIndex, dispatch]\n  );\n\n  useEffect(() => {\n    if (state.focusedNodeId) {\n      scrollToNode(state.focusedNodeId);\n    }\n  }, [state.focusedNodeId, scrollToNode]);\n\n  return {\n    nodes: allVirtualNodes,\n    totalSize: rowVirtualizer.totalSize,\n    toggleNode,\n    focusNode,\n    focusFirst,\n    blur,\n    focusedNodeId: state.focusedNodeId,\n    getTreeProps: useCallback(createTreeProps(dispatch), [dispatch]),\n    scrollToNode,\n  };\n}\n\nfunction createNodeItems<T extends { id: string; children?: T[] }>(\n  nodes: T[],\n  depth = 0,\n  collapsedState: Record<string, boolean> = {}\n): TreeNodeItem<T>[] {\n  return nodes.flatMap((node, index) => {\n    const children = node.children\n      ? collapsedState[node.id]\n        ? []\n        : createNodeItems(node.children, depth + 1, collapsedState)\n      : [];\n    return [\n      {\n        id: node.id,\n        depth,\n        node,\n        pos: index + 1,\n        size: nodes.length,\n        isCollapsed: !!collapsedState[node.id],\n      },\n      ...children,\n    ];\n  });\n}\n\nfunction createTreeProps<T extends { id: string; children?: T[] }>(\n  dispatch: Dispatch<TreeAction>\n): () => React.HTMLAttributes<HTMLElement> {\n  return () => ({\n    role: \"tree\",\n    tabIndex: -1,\n    onKeyDown: (e) => {\n      if (e.defaultPrevented) {\n        return; // Do nothing if the event was already processed\n      }\n\n      switch (e.key) {\n        case \"Home\": {\n          dispatch({ type: \"MOVE_TO_TOP\", source: e.nativeEvent });\n          e.preventDefault();\n          break;\n        }\n        case \"End\": {\n          dispatch({ type: \"MOVE_TO_BOTTOM\", source: e.nativeEvent });\n          e.preventDefault();\n          break;\n        }\n        case \"Down\":\n        case \"ArrowDown\": {\n          dispatch({ type: \"MOVE_DOWN\", source: e.nativeEvent });\n          e.preventDefault();\n          break;\n        }\n        case \"Up\":\n        case \"ArrowUp\": {\n          dispatch({ type: \"MOVE_UP\", source: e.nativeEvent });\n          e.preventDefault();\n          break;\n        }\n        case \"Left\":\n        case \"ArrowLeft\": {\n          if (e.altKey) {\n            dispatch({ type: \"COLLAPSE_ALL_NODES\" });\n          } else {\n            dispatch({\n              type: \"MOVE_LEFT\",\n              source: e.nativeEvent,\n            });\n          }\n          e.preventDefault();\n\n          break;\n        }\n        case \"Right\":\n        case \"ArrowRight\": {\n          dispatch({\n            type: \"MOVE_RIGHT\",\n            source: e.nativeEvent,\n          });\n          e.preventDefault();\n\n          break;\n        }\n      }\n    },\n  });\n}\n\nfunction createItemProps<T extends { id: string; children?: T[] }>(\n  item: TreeNodeItem<T>,\n  virtualItem: VirtualItem,\n  state: TreeState<T>,\n  dispatch: Dispatch<TreeAction>\n): () => React.HTMLAttributes<HTMLElement> {\n  const { depth, pos, size, node, isCollapsed } = item;\n\n  return () => ({\n    \"aria-expanded\": node.children && node.children.length > 0 && !isCollapsed,\n    \"aria-level\": depth + 1,\n    \"aria-posinset\": pos,\n    \"aria-setsize\": size,\n    role: \"treeitem\",\n    tabIndex: node.id === state.focusedNodeId ? -1 : undefined,\n    onClick: (e) => {\n      if (e.defaultPrevented) {\n        return; // Do nothing if the event was already processed\n      }\n\n      if (node.id !== state.focusedNodeId) {\n        dispatch({ type: \"FOCUS_NODE\", id: node.id });\n      }\n    },\n  });\n}\n\n// Finds the node in the list of nodes or recursively in the children\nfunction findNodeInTreeById<T extends { id: string; children?: T[] }>(\n  nodes: T[],\n  id: string\n): T | undefined {\n  const node = nodes.find((node) => node.id === id);\n\n  if (node) {\n    return node;\n  }\n\n  for (const node of nodes) {\n    const foundNode = findNodeInTreeById(node.children || [], id);\n\n    if (foundNode) {\n      return foundNode;\n    }\n  }\n\n  return;\n}\n\nfunction calculatePathToNode<T extends { id: string; children?: T[] }>(\n  nodes: T[],\n  searchNode: T,\n  path: string[] = []\n): string[] | undefined {\n  const nodeIndex = nodes.findIndex((node) => node.id === searchNode.id);\n\n  if (nodeIndex !== -1) {\n    return [...path, searchNode.id];\n  }\n\n  for (const node of nodes) {\n    if (!node.children) {\n      continue;\n    }\n\n    const foundPath = calculatePathToNode(node.children || [], searchNode, [\n      ...path,\n      node.id,\n    ]);\n\n    if (foundPath && foundPath.length > path.length) {\n      return foundPath;\n    }\n  }\n\n  return;\n}\n", "var props = ['bottom', 'height', 'left', 'right', 'top', 'width'];\n\nvar rectChanged = function rectChanged(a, b) {\n  if (a === void 0) {\n    a = {};\n  }\n\n  if (b === void 0) {\n    b = {};\n  }\n\n  return props.some(function (prop) {\n    return a[prop] !== b[prop];\n  });\n};\n\nvar observedNodes =\n/*#__PURE__*/\nnew Map();\nvar rafId;\n\nvar run = function run() {\n  var changedStates = [];\n  observedNodes.forEach(function (state, node) {\n    var newRect = node.getBoundingClientRect();\n\n    if (rectChanged(newRect, state.rect)) {\n      state.rect = newRect;\n      changedStates.push(state);\n    }\n  });\n  changedStates.forEach(function (state) {\n    state.callbacks.forEach(function (cb) {\n      return cb(state.rect);\n    });\n  });\n  rafId = window.requestAnimationFrame(run);\n};\n\nfunction observeRect(node, cb) {\n  return {\n    observe: function observe() {\n      var wasEmpty = observedNodes.size === 0;\n\n      if (observedNodes.has(node)) {\n        observedNodes.get(node).callbacks.push(cb);\n      } else {\n        observedNodes.set(node, {\n          rect: undefined,\n          hasRectChanged: false,\n          callbacks: [cb]\n        });\n      }\n\n      if (wasEmpty) run();\n    },\n    unobserve: function unobserve() {\n      var state = observedNodes.get(node);\n\n      if (state) {\n        // Remove the callback\n        var index = state.callbacks.indexOf(cb);\n        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n        if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n        if (!observedNodes.size) cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\nexport default observeRect;\n//# sourceMappingURL=observe-rect.esm.js.map\n", "import React from 'react'\n\nexport default typeof window !== 'undefined'\n  ? React.useLayoutEffect\n  : React.useEffect\n", "import React from 'react'\nimport observeRect from '@reach/observe-rect'\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nexport default function useRect(\n  nodeRef,\n  initialRect = { width: 0, height: 0 }\n) {\n  const [element, setElement] = React.useState(nodeRef.current)\n  const [rect, dispatch] = React.useReducer(rectReducer, initialRect)\n  const initialRectSet = React.useRef(false)\n\n  useIsomorphicLayoutEffect(() => {\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current)\n    }\n  })\n\n  useIsomorphicLayoutEffect(() => {\n    if (element && !initialRectSet.current) {\n      initialRectSet.current = true\n      const rect = element.getBoundingClientRect()\n      dispatch({ rect })\n    }\n  }, [element])\n\n  React.useEffect(() => {\n    if (!element) {\n      return\n    }\n\n    const observer = observeRect(element, rect => {\n      dispatch({ rect })\n    })\n\n    observer.observe()\n\n    return () => {\n      observer.unobserve()\n    }\n  }, [element])\n\n  return rect\n}\n\nfunction rectReducer(state, action) {\n  const rect = action.rect\n  if (state.height !== rect.height || state.width !== rect.width) {\n    return rect\n  }\n  return state\n}\n", "import React from 'react'\nimport useRect from './useRect'\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nconst defaultEstimateSize = () => 50\n\nconst defaultKeyExtractor = index => index\n\nconst defaultMeasureSize = (el, horizontal) => {\n  const key = horizontal ? 'offsetWidth' : 'offsetHeight'\n\n  return el[key]\n}\n\nexport const defaultRangeExtractor = range => {\n  const start = Math.max(range.start - range.overscan, 0)\n  const end = Math.min(range.end + range.overscan, range.size - 1)\n\n  const arr = []\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i)\n  }\n\n  return arr\n}\n\nexport function useVirtual({\n  size = 0,\n  estimateSize = defaultEstimateSize,\n  overscan = 1,\n  paddingStart = 0,\n  paddingEnd = 0,\n  parentRef,\n  horizontal,\n  scrollToFn,\n  useObserver,\n  initialRect,\n  onScrollElement,\n  scrollOffsetFn,\n  keyExtractor = defaultKeyExtractor,\n  measureSize = defaultMeasureSize,\n  rangeExtractor = defaultRangeExtractor,\n}) {\n  const sizeKey = horizontal ? 'width' : 'height'\n  const scrollKey = horizontal ? 'scrollLeft' : 'scrollTop'\n\n  const latestRef = React.useRef({\n    scrollOffset: 0,\n    measurements: [],\n  })\n\n  const [scrollOffset, setScrollOffset] = React.useState(0)\n  latestRef.current.scrollOffset = scrollOffset\n\n  const useMeasureParent = useObserver || useRect\n\n  const { [sizeKey]: outerSize } = useMeasureParent(parentRef, initialRect)\n\n  latestRef.current.outerSize = outerSize\n\n  const defaultScrollToFn = React.useCallback(\n    offset => {\n      if (parentRef.current) {\n        parentRef.current[scrollKey] = offset\n      }\n    },\n    [parentRef, scrollKey]\n  )\n\n  const resolvedScrollToFn = scrollToFn || defaultScrollToFn\n\n  scrollToFn = React.useCallback(\n    offset => {\n      resolvedScrollToFn(offset, defaultScrollToFn)\n    },\n    [defaultScrollToFn, resolvedScrollToFn]\n  )\n\n  const [measuredCache, setMeasuredCache] = React.useState({})\n\n  const measure = React.useCallback(() => setMeasuredCache({}), [])\n\n  const pendingMeasuredCacheIndexesRef = React.useRef([])\n\n  const measurements = React.useMemo(() => {\n    const min =\n      pendingMeasuredCacheIndexesRef.current.length > 0\n        ? Math.min(...pendingMeasuredCacheIndexesRef.current)\n        : 0\n    pendingMeasuredCacheIndexesRef.current = []\n\n    const measurements = latestRef.current.measurements.slice(0, min)\n\n    for (let i = min; i < size; i++) {\n      const key = keyExtractor(i)\n      const measuredSize = measuredCache[key]\n      const start = measurements[i - 1] ? measurements[i - 1].end : paddingStart\n      const size =\n        typeof measuredSize === 'number' ? measuredSize : estimateSize(i)\n      const end = start + size\n      measurements[i] = { index: i, start, size, end, key }\n    }\n    return measurements\n  }, [estimateSize, measuredCache, paddingStart, size, keyExtractor])\n\n  const totalSize = (measurements[size - 1]?.end || paddingStart) + paddingEnd\n\n  latestRef.current.measurements = measurements\n  latestRef.current.totalSize = totalSize\n\n  const element = onScrollElement ? onScrollElement.current : parentRef.current\n\n  const scrollOffsetFnRef = React.useRef(scrollOffsetFn)\n  scrollOffsetFnRef.current = scrollOffsetFn\n\n  useIsomorphicLayoutEffect(() => {\n    if (!element) {\n      setScrollOffset(0)\n\n      return\n    }\n\n    const onScroll = event => {\n      const offset = scrollOffsetFnRef.current\n        ? scrollOffsetFnRef.current(event)\n        : element[scrollKey]\n\n      setScrollOffset(offset)\n    }\n\n    onScroll()\n\n    element.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true,\n    })\n\n    return () => {\n      element.removeEventListener('scroll', onScroll)\n    }\n  }, [element, scrollKey])\n\n  const { start, end } = calculateRange(latestRef.current)\n\n  const indexes = React.useMemo(\n    () =>\n      rangeExtractor({\n        start,\n        end,\n        overscan,\n        size: measurements.length,\n      }),\n    [start, end, overscan, measurements.length, rangeExtractor]\n  )\n\n  const measureSizeRef = React.useRef(measureSize)\n  measureSizeRef.current = measureSize\n\n  const virtualItems = React.useMemo(() => {\n    const virtualItems = []\n\n    for (let k = 0, len = indexes.length; k < len; k++) {\n      const i = indexes[k]\n      const measurement = measurements[i]\n\n      const item = {\n        ...measurement,\n        measureRef: el => {\n          if (el) {\n            const measuredSize = measureSizeRef.current(el, horizontal)\n\n            if (measuredSize !== item.size) {\n              const { scrollOffset } = latestRef.current\n\n              if (item.start < scrollOffset) {\n                defaultScrollToFn(scrollOffset + (measuredSize - item.size))\n              }\n\n              pendingMeasuredCacheIndexesRef.current.push(i)\n\n              setMeasuredCache(old => ({\n                ...old,\n                [item.key]: measuredSize,\n              }))\n            }\n          }\n        },\n      }\n\n      virtualItems.push(item)\n    }\n\n    return virtualItems\n  }, [indexes, defaultScrollToFn, horizontal, measurements])\n\n  const mountedRef = React.useRef(false)\n\n  useIsomorphicLayoutEffect(() => {\n    if (mountedRef.current) {\n      setMeasuredCache({})\n    }\n    mountedRef.current = true\n  }, [estimateSize])\n\n  const scrollToOffset = React.useCallback(\n    (toOffset, { align = 'start' } = {}) => {\n      const { scrollOffset, outerSize } = latestRef.current\n\n      if (align === 'auto') {\n        if (toOffset <= scrollOffset) {\n          align = 'start'\n        } else if (toOffset >= scrollOffset + outerSize) {\n          align = 'end'\n        } else {\n          align = 'start'\n        }\n      }\n\n      if (align === 'start') {\n        scrollToFn(toOffset)\n      } else if (align === 'end') {\n        scrollToFn(toOffset - outerSize)\n      } else if (align === 'center') {\n        scrollToFn(toOffset - outerSize / 2)\n      }\n    },\n    [scrollToFn]\n  )\n\n  const tryScrollToIndex = React.useCallback(\n    (index, { align = 'auto', ...rest } = {}) => {\n      const { measurements, scrollOffset, outerSize } = latestRef.current\n\n      const measurement = measurements[Math.max(0, Math.min(index, size - 1))]\n\n      if (!measurement) {\n        return\n      }\n\n      if (align === 'auto') {\n        if (measurement.end >= scrollOffset + outerSize) {\n          align = 'end'\n        } else if (measurement.start <= scrollOffset) {\n          align = 'start'\n        } else {\n          return\n        }\n      }\n\n      const toOffset =\n        align === 'center'\n          ? measurement.start + measurement.size / 2\n          : align === 'end'\n          ? measurement.end\n          : measurement.start\n\n      scrollToOffset(toOffset, { align, ...rest })\n    },\n    [scrollToOffset, size]\n  )\n\n  const scrollToIndex = React.useCallback(\n    (...args) => {\n      // We do a double request here because of\n      // dynamic sizes which can cause offset shift\n      // and end up in the wrong spot. Unfortunately,\n      // we can't know about those dynamic sizes until\n      // we try and render them. So double down!\n      tryScrollToIndex(...args)\n      requestAnimationFrame(() => {\n        tryScrollToIndex(...args)\n      })\n    },\n    [tryScrollToIndex]\n  )\n\n  return {\n    virtualItems,\n    totalSize,\n    scrollToOffset,\n    scrollToIndex,\n    measure,\n  }\n}\n\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    let middle = ((low + high) / 2) | 0\n    let currentValue = getCurrentValue(middle)\n\n    if (currentValue < value) {\n      low = middle + 1\n    } else if (currentValue > value) {\n      high = middle - 1\n    } else {\n      return middle\n    }\n  }\n\n  if (low > 0) {\n    return low - 1\n  } else {\n    return 0\n  }\n}\n\nfunction calculateRange({ measurements, outerSize, scrollOffset }) {\n  const size = measurements.length - 1\n  const getOffset = index => measurements[index].start\n\n  let start = findNearestBinarySearch(0, size, getOffset, scrollOffset)\n  let end = start\n\n  while (end < size && measurements[end].end < scrollOffset + outerSize) {\n    end++\n  }\n\n  return { start, end }\n}\n"],
  "mappings": "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",
  "names": []
}
